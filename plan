The current tool_serial_write() cannot continuously flush returned results of commands in a live constant stream like this way ? :

so i would like to implement a workaround using MCP's protocol notifications that will flush live results of the vm output.

use context7


## Live output example:
if (defined $rdr) {
my $flags = fcntl($rdr, F_GETFL, 0);
fcntl($rdr, F_SETFL, $flags | O_NONBLOCK);
}
if (defined $err) {
my $flags = fcntl($err, F_GETFL, 0);
fcntl($err, F_SETFL, $flags | O_NONBLOCK);
}
my $start_read_time = time();
# Boucle pour lire les données disponibles des handles
while ( (!$rdr_closed || !$err_closed) && (!$timeout || (time() - $start_read_time < $timeout)) ) {

my @ready_handles = $sel->can_read(0.1); # Vérifier si des données sont disponibles sur les handles
foreach my $fh (@ready_handles) {
my $buffer;
my $bytes_read = sysread($fh, $buffer, 4096); # Lire les données disponibles
if (defined $bytes_read && $bytes_read > 0) {
my $decoded_chunk = Encode::decode_utf8($buffer);
if ($opts{live} && !$in_confirmation) { # Afficher la sortie en temps réel si 'live' est activé
print $decoded_chunk;
}
if ($fh == $rdr) { $stdout_buf .= $decoded_chunk; }
elsif ($fh == $err) { $stderr_buf .= $decoded_chunk; }
} elsif (defined $bytes_read && $bytes_read == 0) { # Fin de fichier
$sel->remove($fh);
if ($fh == $rdr) { $rdr_closed = 1; close $rdr; }
if (defined $err && $fh == $err) { $err_closed = 1; close $err; }
} elsif (!defined $bytes_read) { # Erreur de lecture
_warn("Erreur de lecture sur le handle: $!");
$sel->remove($fh);
if ($fh == $rdr) { $rdr_closed = 1; close $rdr; }
if ($fh == $err) { $err_closed = 1; close $err; }
}
} 


Keep our current tools/call handlers (start, write, read, etc.) exactly as-is for control-plane actions.

When the PTY loop sees new data, send a JSON-RPC notification on STDOUT:

{"jsonrpc":"2.0","method":"notifications/vm_output","params":{"vm":"vm1","stream":"stdout","chunk":"...","timestamp":"..."}}

MCP clients that understand notifications will render this as live output, while the existing read tool continues to provide pull-based buffered output for compatibility.